# 
# This file is part of the efc project <https://github.com/eurus-project/efc/>.
# Copyright (c) 2024 The efc developers.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

import yaml
from jinja2 import Template
import os

LICENSE_TEXT = """/*
 * This file was autogenerated from a message definition file and is
 * a part of the efc project <https://github.com/eurus-project/efc/>.
 * Copyright (c) 2024 The efc developers.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

"""

HEADER_TEMPLATE = """/**
 * {{ description }}
 */

#ifndef {{ header_guard }}
#define {{ header_guard }}

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "ulog.h"

typedef struct {
    {%- for field in fields %}
    {%- if field.array_length %}
    {{ field.type }}* {{ field.name }}; {%- if field.description %} // {{ field.description }} {%- endif %}
    {%- else %}
    {{ field.type }} {{ field.name }}; {%- if field.description %} // {{ field.description }} {%- endif %}
    {%- endif %}
    {%- endfor %}
} ULOG_{{ struct_name }}_Type;

ULOG_Error_Type ULOG_{{ struct_name }}_RegisterFormat(ULOG_Inst_Type* log);
ULOG_Error_Type ULOG_{{ struct_name }}_Subscribe(ULOG_Inst_Type *log, uint8_t multi_id, uint16_t *msg_id);
ULOG_Error_Type ULOG_{{ struct_name }}_Write(ULOG_Inst_Type *log, const ULOG_{{ struct_name }}_Type* {{ struct_name_lower }}, uint16_t msg_id);

#ifdef __cplusplus
}
#endif

#endif // {{ header_guard }}

"""

SOURCE_TEMPLATE = """#include "{{ header_file }}"
#include <zephyr/fs/fs.h>
#include <string.h>

typedef struct __attribute__((packed)) {
    uint16_t msg_size;
    uint8_t msg_type;
} Message_Header_Type;

static const char format_string[] = "{{ struct_name_lower }}:{% for field in fields %}{{ field.type }}{% if field.array_length %}[{{ field.array_length }}]{% endif %} {{ field.name }};{% endfor %}";

ULOG_Error_Type ULOG_{{ struct_name }}_RegisterFormat(ULOG_Inst_Type* log) {
    if (log == NULL) {
        return ULOG_INVALID_PARAM;
    }

    if (log->phase != ULOG_PHASE_DEFINITIONS) {
        return ULOG_WRONG_PHASE;
    }

    Message_Header_Type header = {
        .msg_type = 'F',
        .msg_size = strlen(format_string),
    };

    int ret = fs_write(&log->file, &header, sizeof(header));
    if (ret < 0) {
        return ULOG_FILESYSTEM_ERROR;
    }

    ret = fs_write(&log->file, format_string, strlen(format_string));
    if (ret < 0) {
        return ULOG_FILESYSTEM_ERROR;
    }

    return ULOG_SUCCESS;
}

ULOG_Error_Type ULOG_{{ struct_name }}_Subscribe(ULOG_Inst_Type *log, uint8_t multi_id, uint16_t *msg_id) {
    if (log == NULL) {
        return ULOG_INVALID_PARAM;
    }

    if (log->phase != ULOG_PHASE_DATA) {
        return ULOG_WRONG_PHASE;
    }

    const char name[] = "{{ struct_name_lower }}";

    Message_Header_Type header = {
        .msg_type = 'A',
        .msg_size = sizeof(multi_id) + sizeof(log->next_msg_id) + strlen(name),
    };

    int ret = fs_write(&log->file, &header, sizeof(header));
    if (ret < 0) {
        return ULOG_FILESYSTEM_ERROR;
    }

    ret = fs_write(&log->file, &multi_id, sizeof(multi_id));
    if (ret < 0) {
        return ULOG_FILESYSTEM_ERROR;
    }

    ret = fs_write(&log->file, &log->next_msg_id, sizeof(log->next_msg_id));
    if (ret < 0) {
        return ULOG_FILESYSTEM_ERROR;
    }

    ret = fs_write(&log->file, name, strlen(name));
    if (ret < 0) {
        return ULOG_FILESYSTEM_ERROR;
    }

    *msg_id = log->next_msg_id;
    log->next_msg_id++;

    return ULOG_SUCCESS;
}

ULOG_Error_Type ULOG_{{ struct_name }}_Write(ULOG_Inst_Type *log, const ULOG_{{ struct_name }}_Type* {{ struct_name_lower }}, const uint16_t msg_id) {
    if (log == NULL || {{ struct_name_lower }} == NULL) {
        return ULOG_INVALID_PARAM;
    }

    if (log->phase != ULOG_PHASE_DATA) {
        return ULOG_WRONG_PHASE;
    }

    Message_Header_Type header = {
        .msg_type = 'D',
        .msg_size = sizeof(msg_id)
            {%- for field in fields %}
            {% if field.array_length %}({{+ field.array_length }} * sizeof({{ field.type }})){% else %}+ sizeof({{ field.type }}){% endif %}
            {%- endfor %},
    };

    // Write the message metadata
    int ret = fs_write(&log->file, &header, sizeof(header));
    if (ret < 0) {
        return ULOG_FILESYSTEM_ERROR;
    }

    ret = fs_write(&log->file, &msg_id, sizeof(msg_id));
    if (ret < 0) {
        return ULOG_FILESYSTEM_ERROR;
    }

    // Write the message data
    {%- for field in fields %}
    ret = fs_write(&log->file, {% if field.array_length %}{{ struct_name_lower }}->{{ field.name }}{% else %}&{{ struct_name_lower }}->{{ field.name }}{% endif %}, {% if field.array_length %}{{ field.array_length }} * sizeof({{ field.type }}){% else %}sizeof({{ field.type }}){% endif %});
    if (ret < 0) {
        return ULOG_FILESYSTEM_ERROR;
    }
    {% endfor %}
    return ULOG_SUCCESS;
}

"""

def capitalize_snake_case(value):
    words = value.split('_')
    return '_'.join(word.capitalize() for word in words)

def check_field_types(message):
    valid_types = ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t",
                   "int64_t", "uint64_t", "float", "double", "char", "bool"]

    for field in message["fields"]:
        if field["type"] not in valid_types:
            raise SystemExit(f"Field {field['name']} in {message['name']} message is of unsupported type - {field['type']}")

def add_timestamp_field(message):
    message["fields"].insert(
        0, 
        {
            "name": "timestamp",
            "type": "uint64_t",
            "description": "Time since boot in microseconds"
        }
    )

def load_message(yaml_file):
    with open(yaml_file, "r") as file:
        return yaml.safe_load(file)

def generate_header(message, output_dir):
    msg_name_lower = message["name"].lower()
    msg_name_capitalized = capitalize_snake_case(msg_name_lower)

    header_guard = f"ULOG_{msg_name_lower.upper()}_H"
    # Use a default description if not provided
    description = message.get("description", "No description provided for this message.")

    header_content = Template(HEADER_TEMPLATE).render(
        struct_name=msg_name_capitalized,
        struct_name_lower=msg_name_lower,
        fields=message["fields"],
        header_guard=header_guard,
        description=description,
    )

    header_filename = os.path.join(output_dir, f"ulog_{msg_name_lower}.h")
    with open(header_filename, "w") as header_file:
        header_file.write(LICENSE_TEXT + header_content)

    return header_filename

def generate_source(message, output_dir):
    msg_name_lower = message["name"].lower()
    msg_name_capitalized = capitalize_snake_case(msg_name_lower)

    source_content = Template(SOURCE_TEMPLATE).render(
        struct_name=msg_name_capitalized,
        struct_name_lower=msg_name_lower,
        fields=message["fields"],
        header_file=f"ulog_{msg_name_lower}.h",
    )

    source_filename = os.path.join(output_dir, f"ulog_{msg_name_lower}.c")
    with open(source_filename, "w") as source_file:
        source_file.write(LICENSE_TEXT + source_content)

    return source_filename

def process_message_file(yaml_file, output_dir):
    message = load_message(yaml_file)
    check_field_types(message)
    add_timestamp_field(message)
    generate_header(message, output_dir)
    generate_source(message, output_dir)

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Generate header and source files for an ULOG message from YAML definitions.")
    parser.add_argument("input_file", help="Input YAML file")
    parser.add_argument("output_dir", help="Directory for generated files")

    args = parser.parse_args()

    if not args.input_file.endswith(".yaml"):
        raise SystemExit(f"The file {args.input_file} is not a YAML file!")

    os.makedirs(args.output_dir, exist_ok=True)

    process_message_file(args.input_file, args.output_dir)

    print(f"Generated files in {args.output_dir}.")
